<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>World Country Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
  :root {
    /* Classy ‚Äúmidnight + glass‚Äù palette */
    --bg: #0b1220;
    --bg-soft: #0a1020;

    --accent: #60a5fa;          /* softer blue */
    --accent-strong: #38bdf8;   /* highlight */
    --text: #eef2ff;
    --muted: rgba(226, 232, 240, 0.68);

    --danger: #fb7185;
    --success: #34d399;

    /* lighter borders */
    --border: rgba(148, 163, 184, 0.22);

    --radius-lg: 18px;
    --radius-md: 12px;

    /* reusable ‚Äúglass‚Äù surfaces */
    --glass: rgba(15, 23, 42, 0.55);
    --glass-strong: rgba(15, 23, 42, 0.72);

    /* shadows */
    --shadow-lg: 0 24px 55px rgba(2, 6, 23, 0.55);
    --shadow-md: 0 14px 34px rgba(2, 6, 23, 0.45);
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    min-height: 100vh;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
    color: var(--text);

    /* brighter, more elegant background */
    background:
      radial-gradient(1100px 700px at 20% 0%, rgba(96, 165, 250, 0.18), transparent 55%),
      radial-gradient(900px 600px at 90% 10%, rgba(56, 189, 248, 0.14), transparent 52%),
      radial-gradient(900px 600px at 60% 100%, rgba(148, 163, 184, 0.10), transparent 55%),
      linear-gradient(180deg, #0b1220 0%, #060b18 70%, #050814 100%);
    display: flex;
    align-items: stretch;
    justify-content: center;
  }

  .app {
    width: 100%;
    max-width: 1200px;
    margin: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  header {
    background: linear-gradient(90deg, rgba(2, 132, 199, 0.92), rgba(96, 165, 250, 0.92));
    color: white;
    padding: 14px 20px;
    border-radius: var(--radius-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-wrap: wrap;

    /* more refined shadow + subtle highlight */
    box-shadow: var(--shadow-md);
    border: 1px solid rgba(148, 163, 184, 0.22);
    position: relative;
    overflow: hidden;
  }

  header::after {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(900px 220px at 20% 0%, rgba(255,255,255,0.16), transparent 65%);
    pointer-events: none;
  }

  header h1 {
    margin: 0;
    font-size: 1.3rem;
    letter-spacing: 0.04em;
  }

  header span {
    font-size: 0.85rem;
    opacity: 0.92;
  }

  main {
    flex: 1;
    display: grid;
    grid-template-columns: minmax(260px, 360px) minmax(0, 1fr);
    gap: 12px;
  }

  .panel {
    /* glass panel */
    background:
      radial-gradient(900px 500px at 10% 0%, rgba(255,255,255,0.06), transparent 55%),
      var(--glass);
    border-radius: var(--radius-lg);
    padding: 16px 16px 14px;

    border: 1px solid var(--border);
    box-shadow: var(--shadow-lg);

    display: flex;
    flex-direction: column;
    gap: 12px;

    /* slight blur for that ‚Äúclassy‚Äù glass feel */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .panel h2 {
    margin: 0 0 2px;
    font-size: 0.98rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: rgba(226, 232, 240, 0.62);
  }

  .panel .hint {
    font-size: 0.82rem;
    color: var(--muted);
    margin-bottom: 4px;
    line-height: 1.35;
  }

  .field { display: flex; flex-direction: column; gap: 6px; }
  .field label { font-size: 0.82rem; color: rgba(226, 232, 240, 0.70); }

  select,
  input[type="password"]{
    background: rgba(2, 6, 23, 0.35);
    color: var(--text);
    border-radius: var(--radius-md);
    border: 1px solid rgba(148, 163, 184, 0.28);
    padding: 8px 10px;
    font-size: 0.88rem;
    outline: none;
    appearance: none;
  }

  select:focus,
  input[type="password"]:focus{
    border-color: rgba(96, 165, 250, 0.85);
    box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.18);
  }

  .api-key-help{
    font-size: 0.8rem;
    color: var(--muted);
    line-height: 1.35;
  }

  .api-key-row{
    display: flex;
    gap: 8px;
    margin-top: 6px;
    flex-wrap: wrap;
  }

  .toggle {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border-radius: var(--radius-md);

    background: rgba(2, 6, 23, 0.25);
    border: 1px solid rgba(148, 163, 184, 0.22);

    font-size: 0.85rem;
    color: var(--muted);

    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
  }
  .toggle input { transform: translateY(1px); }

  .question {
    margin-top: 6px;
    padding: 10px 10px;
    border-radius: var(--radius-md);

    background: rgba(2, 6, 23, 0.35);
    border: 1px solid rgba(148, 163, 184, 0.28);

    font-size: 0.95rem;
    line-height: 1.4;

    box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
  }

  .question span.label {
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.14em;
    color: rgba(226, 232, 240, 0.62);
    display: block;
    margin-bottom: 2px;
  }

  .question strong { color: var(--accent-strong); font-size: 1rem; }

  .stats {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
    font-size: 0.82rem;
  }

  .pill {
    padding: 5px 8px;
    border-radius: 999px;
    background: rgba(2, 6, 23, 0.25);
    border: 1px solid rgba(148, 163, 184, 0.26);
    display: flex;
    align-items: center;
    gap: 4px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
  }

  .pill span.label {
    color: rgba(226, 232, 240, 0.62);
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
  }

  .pill span.value { font-weight: 650; color: var(--text); }
  .pill .highlight { color: var(--accent); }

  .buttons { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }

  button {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.28);
    padding: 8px 12px;
    font-size: 0.82rem;
    cursor: pointer;

    background: rgba(2, 6, 23, 0.25);
    color: var(--text);

    display: inline-flex;
    align-items: center;
    gap: 4px;

    transition: transform 0.10s ease, box-shadow 0.10s ease, border-color 0.10s ease, background 0.10s ease;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
  }

  button.primary {
    background: linear-gradient(135deg, rgba(96, 165, 250, 0.95), rgba(56, 189, 248, 0.95));
    border-color: transparent;
    color: #061021;
    font-weight: 650;
    box-shadow: 0 14px 30px rgba(56, 189, 248, 0.22);
  }

  button:hover:not(:disabled) {
    transform: translateY(-1px);
    border-color: rgba(226, 232, 240, 0.35);
    background: rgba(2, 6, 23, 0.35);
    box-shadow: 0 14px 34px rgba(2, 6, 23, 0.55);
  }

  button.primary:hover:not(:disabled) { box-shadow: 0 18px 38px rgba(56, 189, 248, 0.28); }
  button:disabled { opacity: 0.55; cursor: default; box-shadow: none; }

  .feedback { min-height: 20px; font-size: 0.86rem; margin-top: 6px; }
  .feedback.correct { color: var(--success); }
  .feedback.wrong { color: var(--danger); }
  .feedback.neutral { color: var(--muted); }

  .map-shell {
    /* make the map container feel ‚Äúpremium‚Äù */
    background:
      radial-gradient(1200px 600px at 30% 0%, rgba(255,255,255,0.06), transparent 60%),
      var(--glass-strong);
    border-radius: var(--radius-lg);
    border: 1px solid rgba(148, 163, 184, 0.24);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow-lg);

    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .map-header {
    padding: 10px 14px;
    font-size: 0.84rem;
    color: var(--muted);
    border-bottom: 1px solid rgba(148, 163, 184, 0.22);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-wrap: wrap;

    background: rgba(2, 6, 23, 0.18);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
  }

  .map-header span.region-label { font-weight: 550; color: var(--text); }

  /* Map looks less flat + nicer tiles */
  #map {
    flex: 1;
    min-height: 420px;

    /* if tiles are slow/blank, this background feels ‚Äúclean‚Äù */
    background:
      radial-gradient(900px 500px at 30% 0%, rgba(255,255,255,0.08), transparent 60%),
      linear-gradient(180deg, rgba(15, 23, 42, 0.55), rgba(2, 6, 23, 0.85));

    /* subtle ‚Äúlift‚Äù without making it cartoonish */
    filter: saturate(1.08) contrast(1.03);
  }

  .badge {
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.34);
    font-size: 0.75rem;
    color: rgba(226, 232, 240, 0.68);
    background: rgba(2, 6, 23, 0.22);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
  }

  .badge.ready { border-color: rgba(52, 211, 153, 0.6); color: var(--success); }

  @media (max-width: 900px) {
    main { grid-template-columns: 1fr; }
    #map { min-height: 320px; }
  }
</style>

</head>
<body>
  <div class="app">
    <header>
      <h1>World Country Trainer</h1>
      <span>Click the correct country to lock it in your memory.</span>
    </header>

    <main>
      <section class="panel">
        <h2>Quiz Controls</h2>
        <p class="hint">
          1) Pick a region ¬∑ 2) The app names a country ¬∑ 3) Click it on the map.<br/>
          <b>This build uses your iso_regions.csv</b> (UN M49 regions) so continents populate correctly even when the GeoJSON has no continent fields.
        </p>

        <div class="field">
          <label for="regionSelect">Region / Continent</label>
          <select id="regionSelect" disabled>
            <option value="">Loading country data...</option>
          </select>
        </div>
	<div class="field">
  	<label for="basemapSelect">Map style</label>
	  <select id="basemapSelect">
  	  <option value="light" selected>Light</option>
   	 <option value="color">Color</option>
   	 <option value="dark">Dark</option>
 	 </select>
	</div>

        <div class="toggle" title="Antarctica isn't usually quizzed as a country. Turn on if you want it included.">
          <input id="includeAntarctica" type="checkbox" />
          <label for="includeAntarctica">Include Antarctica</label>
        </div>

        <div class="question" id="questionBox">
          <span class="label">Next country</span>
          <div id="questionText">Choose a region to begin.</div>
        </div>

        <div class="stats">
          <div class="pill">
            <span class="label">Score</span>
            <span class="value"><span id="score">0</span>/<span id="total">0</span></span>
          </div>
          <div class="pill">
            <span class="label">Streak</span>
            <span class="value highlight" id="streak">0</span>
          </div>
          <div class="pill">
            <span class="label">Region done</span>
            <span class="value" id="progressLabel">0%</span>
          </div>
        </div>
	<div class="field" style="margin-top:10px;">
 	 <label for="apiKeyInput">OpenAI API Key (for hints)</label>
 	 <input id="apiKeyInput" type="password" placeholder="sk-..." autocomplete="off" />
 	 <div class="api-key-help">
 	   This key is sent only to your local Python server and is kept only while the 	server is running.
 	 </div>
  	<div class="api-key-row">
 	   <button id="saveKeyBtn" type="button">Use this key</button>
 	   <button id="clearKeyBtn" type="button">Clear key</button>
 	 </div>
	</div>

        <div class="buttons">
          <button id="skipBtn" type="button">Skip</button>
	<button id="hintBtn" type="button">Hint</button>
          <button id="resetBtn" type="button">Reset region</button>
          <button id="shuffleBtn" type="button" class="primary">New round</button>
        </div>

        <div class="feedback neutral" id="feedback"></div>
      </section>

      <section class="map-shell">
        <div class="map-header">
          <div>
            Region: <span class="region-label" id="currentRegionLabel">None selected</span>
          </div>
          <div class="badge" id="dataStatus">Loading data‚Ä¶</div>
        </div>
        <div id="map"></div>
      </section>
    </main>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // -----------------------------
    // Files
    // -----------------------------
    const COUNTRIES_GEOJSON_PATH = "data/countries.geojson";
    const ISO_REGIONS_CSV_PATH = "data/iso_regions.csv";

    // No-label basemap so country names are NOT visible.
	const TILE_ATTRIB =
  	'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> 	contributors ' +
  	'&copy; <a href="https://carto.com/attributions">CARTO</a>';

	const BASEMAPS = {
 	 light: "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
 	 color: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}	{r}.png",
 	 dark:  "https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png"
	};


    // Middle East teaching list (used for a Middle East region selector)
    const MIDDLE_EAST_NAMES = new Set([
      "Turkey","Cyprus","Syria","Lebanon","Israel","Palestine","Jordan","Iraq","Iran",
      "Saudi Arabia","Kuwait","Bahrain","Qatar","United Arab Emirates","Oman","Yemen","Egypt",
      "Armenia","Azerbaijan","Georgia"
    ]);

    // ISO3 -> { region, subRegion, intermediateRegion } loaded from iso_regions.csv
    const ISO_REGION_MAP = new Map();

    // -----------------------------
    // Helpers
    // -----------------------------

    function getPropAny(p, keys) {
      for (const k of keys) {
        if (p && p[k] !== undefined && p[k] !== null && String(p[k]).trim() !== "") return String(p[k]).trim();
      }
      return "";
    }

    function getCountryName(feature) {
      const p = feature.properties || {};
      return getPropAny(p, [
        "name","NAME","Name","ADMIN","admin","SOVEREIGNT","sovereignt","formal_en","NAME_EN","NAME_LONG","name_long","COUNTRY","country"
      ]) || "Unknown";
    }

    function getISO3(feature) {
      const p = feature.properties || {};
      const iso = getPropAny(p, [
        // Common datasets
        "ISO_A3","iso_a3","ADM0_A3","adm0_a3","ISO3","iso3",
        // Your dataset
        "ISO3166-1-Alpha-3","ISO3166_1_Alpha_3","ALPHA3","alpha-3","Alpha-3"
      ]);
      if (iso === "-99") return "";
      return iso;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // CSV parsing (handles quoted commas)
    function parseCSVLine(line) {
      const out = [];
      let cur = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (ch === ',' && !inQuotes) {
          out.push(cur);
          cur = "";
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      return out;
    }

    function loadIsoRegionsCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) return;
      const header = parseCSVLine(lines[0]).map(h => h.trim());
      const idx = (name) => header.findIndex(h => h === name);

      const iA3 = idx("alpha-3");
      const iRegion = idx("region");
      const iSub = idx("sub-region");
      const iInter = idx("intermediate-region");
      if (iA3 < 0) return;

      for (let i = 1; i < lines.length; i++) {
        const row = parseCSVLine(lines[i]);
        const a3 = (row[iA3] || "").trim();
        if (!a3) continue;
        ISO_REGION_MAP.set(a3, {
          region: (row[iRegion] || "").trim(),
          subRegion: (row[iSub] || "").trim(),
          intermediateRegion: (row[iInter] || "").trim()
        });
      }
    }

    // Continent classification based on iso_regions.csv
    function classifyContinent(feature) {
      const iso3 = getISO3(feature);
      if (!iso3 || !ISO_REGION_MAP.has(iso3)) return "Other";

      const info = ISO_REGION_MAP.get(iso3);
      const region = (info.region || "").toLowerCase();
      const inter = (info.intermediateRegion || "").toLowerCase();

      if (region === "africa") return "Africa";
      if (region === "europe") return "Europe";
      if (region === "asia") return "Asia";
      if (region === "oceania") return "Oceania";
      if (region === "americas") {
        // iso_regions.csv uses intermediate-region = South America for South American states.
        if (inter === "south america") return "South America";
        return "North America"; // includes Northern America + Caribbean + Central America
      }
      return "Other";
    }

    function isMiddleEast(feature) {
      const name = getCountryName(feature);
      const iso3 = getISO3(feature);
      if (MIDDLE_EAST_NAMES.has(name)) return true;
      if (iso3 && ISO_REGION_MAP.has(iso3)) {
        const sub = (ISO_REGION_MAP.get(iso3).subRegion || "").toLowerCase();
        if (sub === "western asia") return true;
      }
      if (name === "Egypt") return true;
      return false;
    }

    // -----------------------------
    // Map
    // -----------------------------

    const map = L.map("map", {
      center: [20, 0],
      zoom: 2,
      worldCopyJump: true,
      zoomControl: true
    });

   	const basemapSelect = document.getElementById("basemapSelect");
	let baseLayer = null;

	function setBasemap(which) {
  	const url = BASEMAPS[which] || BASEMAPS.light;

 	 if (baseLayer) map.removeLayer(baseLayer);

 	 baseLayer = L.tileLayer(url, {
   	 maxZoom: 8,      // keep your existing zoom limits
   	 minZoom: 1,
   	 attribution: TILE_ATTRIB
 	 }).addTo(map);
	}

	// Default on load
	setBasemap("light");

	// When the user changes the dropdown
	basemapSelect.addEventListener("change", () => {
 	 setBasemap(basemapSelect.value);
	});


    // Lighter, friendlier palette (works great on Light or Color basemaps)
	const defaultCountryStyle = {
 	 color: "rgba(30, 41, 59, 0.65)",      // border (soft slate)
 	 weight: 1.2,
 	 fillColor: "rgba(59, 130, 246, 0.35)",// fill (soft blue)
 	 fillOpacity: 0.18
	};

	const hoverStyle = {
	  weight: 2.2,
  	color: "rgba(2, 132, 199, 0.95)",     // bright blue outline
  	fillOpacity: 0.28
	};

	const correctStyle = {
  	weight: 2.4,
  	color: "rgba(34, 197, 94, 0.95)",     // green outline
  	fillColor: "rgba(34, 197, 94, 0.35)",
  	fillOpacity: 0.35
	};

	const wrongStyle = {
 	 weight: 2.4,
  	color: "rgba(239, 68, 68, 0.95)",     // red outline
  	fillColor: "rgba(239, 68, 68, 0.30)",
 	 fillOpacity: 0.35
	};


    // -----------------------------
    // State
    // -----------------------------

    let allFeatures = [];
    let buckets = new Map();

    let currentLayer = null;
    let currentRegionKey = null;
    let available = [];
    let totalInRegion = 0;
    let currentTarget = null;

    let score = 0;
    let streak = 0;

    // -----------------------------
    // UI
    // -----------------------------

    const regionSelect = document.getElementById("regionSelect");
    const includeAntarctica = document.getElementById("includeAntarctica");
    const questionText = document.getElementById("questionText");
    const feedbackEl = document.getElementById("feedback");
    const scoreEl = document.getElementById("score");
    const totalEl = document.getElementById("total");
    const streakEl = document.getElementById("streak");
    const progressLabel = document.getElementById("progressLabel");
    const skipBtn = document.getElementById("skipBtn");
    const resetBtn = document.getElementById("resetBtn");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const currentRegionLabel = document.getElementById("currentRegionLabel");
    const dataStatus = document.getElementById("dataStatus");
	const hintBtn = document.getElementById("hintBtn");
	const apiKeyInput = document.getElementById("apiKeyInput");
const saveKeyBtn = document.getElementById("saveKeyBtn");
const clearKeyBtn = document.getElementById("clearKeyBtn");

let apiKeyReady = false;


async function getHint(countryName, regionName) {
  const prompt =
    `Give one short geographic hint to find ${countryName} in ${regionName}. ` +
    `No spoilers.`;

  const r = await fetch("/api/hint", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  // Read as text first (works whether the server returned JSON or plain text)
  const raw = await r.text();

  // Try to parse JSON if possible
  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}

  if (!r.ok) {
    // Prefer server-provided error message
    const errVal = data && data.error ? data.error : raw;
    const msg = (typeof errVal === "string") ? errVal : JSON.stringify(errVal);
    throw new Error(msg);
  }

  // Success case
  if (data && typeof data.text === "string") return data.text;

  // Fallback
  return raw;
}


    function setFeedback(message, type = "neutral") {
      feedbackEl.textContent = message;
      feedbackEl.className = "feedback " + type;
    }
async function setApiKeyOnServer(key) {
  const r = await fetch("/api/set_key", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ key })
  });

  const raw = await r.text();
  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}

  if (!r.ok) {
    const msg = data && data.error ? data.error : raw;
    throw new Error(typeof msg === "string" ? msg : JSON.stringify(msg));
  }

  apiKeyReady = true;
}

    function updateStats() {
      scoreEl.textContent = String(score);
      totalEl.textContent = String(totalInRegion);
      streakEl.textContent = String(streak);
      const completed = totalInRegion === 0 ? 0 : Math.round(((totalInRegion - available.length) / totalInRegion) * 100);
      progressLabel.textContent = completed + "%";
    }

    function enableControls(enabled) {
      skipBtn.disabled = !enabled;
      resetBtn.disabled = !enabled;
      shuffleBtn.disabled = !enabled;
    }

    function resetRegionStats() {
      score = 0;
      streak = 0;
      updateStats();
    }

    function setQuestion(feature) {
      const name = getCountryName(feature);
      questionText.innerHTML = `Locate <strong>${escapeHtml(name)}</strong> on the map.`;
    }

    // -----------------------------
    // Bucketing
    // -----------------------------

    function dedupeFeatures(features) {
      const seen = new Set();
      const out = [];
      for (const f of features) {
        const iso3 = getISO3(f);
        const name = getCountryName(f);
        const key = iso3 ? `ISO3:${iso3}` : `NAME:${name}`;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(f);
      }
      return out;
    }

    function shouldIncludeFeature(feature) {
      const name = getCountryName(feature);
      if (!includeAntarctica.checked && name === "Antarctica") return false;
      if (name === "" || name === "Unknown") return false;
      return true;
    }

    function buildBuckets() {
      buckets = new Map();
      const add = (key, feature) => {
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(feature);
      };

      const filtered = allFeatures.filter(shouldIncludeFeature);

      for (const f of filtered) add("world", f);

      for (const f of filtered) {
        const cont = classifyContinent(f);
        if (cont === "Africa") add("africa", f);
        if (cont === "Europe") add("europe", f);
        if (cont === "Asia") add("asia", f);
        if (cont === "North America") add("north-america", f);
        if (cont === "South America") add("south-america", f);
        if (cont === "Oceania") add("oceania", f);
        if (isMiddleEast(f)) add("middle-east", f);
      }

      for (const key of ["world","africa","europe","asia","north-america","south-america","oceania","middle-east"]) {
        if (!buckets.has(key)) buckets.set(key, []);
      }
    }

    function setRegionOptions() {
      const defs = [
        ["world", "World (all countries)"],
        ["africa", "Africa"],
        ["europe", "Europe"],
        ["asia", "Asia"],
        ["north-america", "North America"],
        ["south-america", "South America"],
        ["oceania", "Oceania"],
        ["middle-east", "Middle East (region)"]
      ];

      regionSelect.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "-- Choose a region --";
      regionSelect.appendChild(placeholder);

      for (const [key, label] of defs) {
        const opt = document.createElement("option");
        const n = (buckets.get(key) || []).length;
        opt.value = key;
        opt.textContent = `${label} (${n})`;
        if (key !== "world" && n === 0) opt.disabled = true;
        regionSelect.appendChild(opt);
      }
    }

    // -----------------------------
    // Quiz logic
    // -----------------------------

    function pickNext() {
      if (!available.length) {
        currentTarget = null;
        questionText.innerHTML = "You finished this region! üéâ Choose another region or start a new round.";
        setFeedback("Excellent work. Try another region to reinforce your memory.", "correct");
        return;
      }
      const idx = Math.floor(Math.random() * available.length);
      currentTarget = available[idx];
      setQuestion(currentTarget);
      setFeedback("Click the correct country on the map.", "neutral");
    }

    function onCountryClicked(e) {
      const layer = e.target;
      const feature = layer.feature;
      if (!currentTarget) return;

      const clickedName = getCountryName(feature);
      const targetName = getCountryName(currentTarget);

      if (clickedName === targetName) {
        feature.__locked = true;
        layer.setStyle(correctStyle);

        // Reveal name only after correct click
        layer.bindPopup(`<b>${escapeHtml(targetName)}</b>`, { closeButton: false, autoClose: true, closeOnClick: true })
          .openPopup();

        score++;
        streak++;
        available = available.filter(f => getCountryName(f) !== targetName);
        setFeedback("Correct! ‚úî Keep going.", "correct");
        updateStats();

        setTimeout(() => pickNext(), 450);
      } else {
        streak = 0;
        updateStats();
        setFeedback(`Not quite ‚Äì that was ${clickedName}. Try again.`, "wrong");
        layer.setStyle(wrongStyle);
        setTimeout(() => {
          if (!feature.__locked && currentLayer) currentLayer.resetStyle(layer);
        }, 700);
      }
    }

    function onHover(e) {
      const layer = e.target;
      if (layer.feature.__locked) return;
      layer.setStyle(hoverStyle);
      layer.bringToFront();
    }

    function onOut(e) {
      const layer = e.target;
      if (!currentLayer) return;
      if (layer.feature.__locked) return;
      currentLayer.resetStyle(layer);
    }

    function buildLayerForRegion(regionKey) {
      const features = (buckets.get(regionKey) || []).slice();

      currentRegionKey = regionKey;
      currentRegionLabel.textContent = regionSelect.options[regionSelect.selectedIndex]?.textContent?.replace(/\s*\(\d+\)\s*$/, "") || regionKey;

      if (currentLayer) {
        currentLayer.remove();
        currentLayer = null;
      }

      for (const f of features) f.__locked = false;

      available = features.slice();
      totalInRegion = features.length;
      resetRegionStats();

      if (!features.length) {
        setFeedback("No countries found for this region in your data.", "wrong");
        questionText.textContent = "No data for this region.";
        enableControls(false);
        return;
      }

      currentLayer = L.geoJSON(features, {
        style: defaultCountryStyle,
        onEachFeature: (feature, layer) => {
          // no tooltips (they reveal names)
          layer.on({ click: onCountryClicked, mouseover: onHover, mouseout: onOut });
        }
      }).addTo(map);

      try {
        const bounds = currentLayer.getBounds();
        if (bounds.isValid()) map.fitBounds(bounds, { padding: [20, 20] });
      } catch (e) {
        map.setView([20, 0], 2);
      }

      enableControls(true);
      pickNext();
    }

    // -----------------------------
    // Events
    // -----------------------------

    regionSelect.addEventListener("change", (e) => {
      const value = e.target.value;
      if (!value) {
        currentRegionKey = null;
        currentRegionLabel.textContent = "None selected";
        questionText.textContent = "Choose a region to begin.";
        setFeedback("Pick a region to start quizzing.", "neutral");
        enableControls(false);
        return;
      }
      buildLayerForRegion(value);
    });

    includeAntarctica.addEventListener("change", () => {
      buildBuckets();
      setRegionOptions();
      if (currentRegionKey) {
        regionSelect.value = currentRegionKey;
        buildLayerForRegion(currentRegionKey);
      }
    });
	saveKeyBtn.addEventListener("click", async () => {
  	const key = (apiKeyInput.value || "").trim();

 	 if (!key) {
  	  apiKeyReady = false;
   	 setFeedback("Enter API key.", "wrong");
   	 apiKeyInput.focus();
   	 return;
 	 }

  	saveKeyBtn.disabled = true;
 	 try {
  	  await setApiKeyOnServer(key);
    	setFeedback("API key set. Hints are enabled.", "correct");
 	 } catch (e) {
  	  apiKeyReady = false;
 	   const msg = (e && e.message) ? e.message : (typeof e === "string" ? e : 	JSON.stringify(e));
	    setFeedback("API key error: " + msg, "wrong");
	  } finally {
  	  saveKeyBtn.disabled = false;
 	 }
	});

	clearKeyBtn.addEventListener("click", () => {
 	 apiKeyInput.value = "";
 	 apiKeyReady = false;
  	setFeedback("API key cleared. Hints disabled.", "neutral");
	});

    skipBtn.addEventListener("click", () => {
      if (!currentTarget || !available.length) return;
      pickNext();
      setFeedback("Skipped. New country selected.", "neutral");
    });

    resetBtn.addEventListener("click", () => {
      if (!currentRegionKey) return;
      buildLayerForRegion(currentRegionKey);
      setFeedback("Region reset. Starting over.", "neutral");
    });

    shuffleBtn.addEventListener("click", () => {
      if (!currentRegionKey) return;
      buildLayerForRegion(currentRegionKey);
      setFeedback("New round started for this region.", "neutral");
    });
async function getHint(countryName, regionName) {
  const prompt =
    `Give one short geographic hint to find ${countryName} in ${regionName}. ` +
    `No spoilers.`;

  const r = await fetch("/api/hint", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  // Read as text first so we can handle both JSON and plain-text errors safely
  const raw = await r.text();

  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}

  if (!r.ok) {
    const errVal = data && data.error ? data.error : raw;
    const msg = (typeof errVal === "string") ? errVal : JSON.stringify(errVal);
    throw new Error(msg);
  }

  if (data && typeof data.text === "string") return data.text;
  return raw;
}

// Only attach if the button exists
if (hintBtn) {
  hintBtn.addEventListener("click", async () => {
    if (!currentTarget) return;

	if (!apiKeyReady) {
  	setFeedback("Enter API key.", "wrong");
  	apiKeyInput.focus();
	  return;
	}

    const countryName = getCountryName(currentTarget);
    const regionName = (currentRegionLabel && currentRegionLabel.textContent) ? currentRegionLabel.textContent : "this region";

    hintBtn.disabled = true;
    try {
      const hint = await getHint(countryName, regionName);
      setFeedback("Hint: " + hint, "neutral");
    } catch (e) {
      const msg = (e && e.message) ? e.message : (typeof e === "string" ? e : JSON.stringify(e));
      setFeedback("Hint error: " + msg, "wrong");
    } finally {
      hintBtn.disabled = false;
    }
  });
}


    // -----------------------------
    // Load data
    // -----------------------------

    enableControls(false);

    Promise.all([
      fetch(COUNTRIES_GEOJSON_PATH).then(r => {
        if (!r.ok) throw new Error("Failed to load countries.geojson: " + r.status);
        return r.json();
      }),
      fetch(ISO_REGIONS_CSV_PATH).then(r => {
        if (!r.ok) throw new Error("Failed to load iso_regions.csv: " + r.status);
        return r.text();
      })
    ])
      .then(([geo, csvText]) => {
        loadIsoRegionsCSV(csvText);

        const features = Array.isArray(geo?.features) ? geo.features : (Array.isArray(geo) ? geo : null);
        if (!features) throw new Error("Unexpected GeoJSON format. Expected FeatureCollection.");

        allFeatures = dedupeFeatures(features);

        buildBuckets();
        setRegionOptions();

        dataStatus.textContent = `Data loaded (${allFeatures.length} features) + regions (${ISO_REGION_MAP.size})`;
        dataStatus.classList.add("ready");

        regionSelect.disabled = false;
        setFeedback("Pick a region to start quizzing.", "neutral");
      })
      .catch(err => {
        console.error(err);
        dataStatus.textContent = "Error loading data";
        setFeedback(
          "Could not load data files. Make sure you're running via http://localhost and you have: data/countries.geojson AND data/iso_regions.csv.",
          "wrong"
        );
        regionSelect.disabled = true;
      });
  </script>
</body>
</html>
